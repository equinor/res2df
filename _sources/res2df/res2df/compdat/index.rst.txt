res2df.compdat
==============

.. py:module:: res2df.compdat

.. autoapi-nested-parse::

   Parser and dataframe generator for the keywords:
   * COMPDAT
   * COMPLUMP
   * COMPSEGS
   * WELOPEN
   * WELSEGS
   * WLIST
   * WSEGAICD
   * WSEGSICD
   * WSEGVALV



Functions
---------

.. autoapisummary::

   res2df.compdat.deck2dfs
   res2df.compdat.expand_welopen
   res2df.compdat.expand_welopen_defaults
   res2df.compdat.expand_welopen_wildcards
   res2df.compdat.unrolldf
   res2df.compdat.unroll_complump
   res2df.compdat.expand_wlist
   res2df.compdat.expand_complump_in_welopen_df
   res2df.compdat.expand_wlist_in_welopen_df
   res2df.compdat.applywelopen
   res2df.compdat.fill_parser
   res2df.compdat.compdat_main
   res2df.compdat.df


Module Contents
---------------

.. py:function:: deck2dfs(deck: opm.io.Deck, start_date: str | datetime.date | None = None, unroll: bool = True) -> dict[str, pandas.DataFrame]

   Loop through the :term:`deck` and pick up information found

   The loop over the :term:`deck` is a state machine, as it has to pick up dates and
   potential information from the WELSPECS keyword.

   :param deck: A :term:`deck` representing the schedule
   :param start_date: The default date to use for
                      events where the DATE or START keyword is not found in advance.
                      Default: None
   :param unroll: Whether to unroll rows that cover a range,
                  like K1 and K2 in COMPDAT and in WELSEGS. Defaults to True.

   :returns: Dictionary with dataframes, at least for COMPDAT, COMPSEGS and WELSEGS.


.. py:function:: expand_welopen(welopen_df: pandas.DataFrame, compdat_df: pandas.DataFrame) -> pandas.DataFrame

   Expands WELOPEN. First wildcard wells are expanded and then default
   coordinates are expanded. The order of the expansion is important.


.. py:function:: expand_welopen_defaults(welopen_df: pandas.DataFrame, compdat_df: pandas.DataFrame) -> pandas.DataFrame

   Expands rows in WELOPEN where one or two coordinates are defaulted.
   Expansion happens by filtering on compdat rows that are matching the
   well name and the coordinates that are not defaulted.

   If all coordinates (I, J, K) are defaulted then the WELOPEN keyword
   is acting on the well and not on the connections, and shall not be
   expanded.

   It is important that expansion of wildcard wells is done prior to
   this function and that COMPDAT is unrolled so that K1=K2 in the input
   to this functions.


.. py:function:: expand_welopen_wildcards(welopen_df: pandas.DataFrame, compdat_df: pandas.DataFrame) -> pandas.DataFrame

   Expand rows in welopen with well names containing wildcard characters,
   with the correct wells from compdat_df that was defined at that date

   Example::

     WELOPEN
      'OP*' 'SHUT' /
     /

   might become the equivalent dataframe representation of::

     WELOPEN
      'OP1' 'SHUT' /
      'OP2' 'SHUT' /
     /

   if both OP1 and OP2 are defined at that time.

   :param welopen_df: DataFrame with welopen
   :param compdat_df: DataFrame with compdat

   :returns: Expanded welopen dataframe


.. py:function:: unrolldf(dframe: pandas.DataFrame, start_column: str = 'K1', end_column: str = 'K2') -> pandas.DataFrame

   Unroll dataframes, where some column pairs indicate
   a range where data applies.

   After unrolling, column pairs with ranges are transformed
   into multiple rows, with no ranges.

   Example: COMPDAT supports K1, K2 intervals for multiple cells::

     COMPDAT
       'OP1' 33 44 10 11 /
     /

   is transformed/unrolled so it would be equal to::

     COMPDAT
       'OP1' 33 44 10 10 /
       'OP1' 33 44 11 11 /
     /

   The latter is easier to work with in Pandas dataframes

   :param dframe: Dataframe to be unrolled
   :param start_column: Column name that contains the start of
                        a range.
   :param end_column Column name that contains the corresponding end: of the range.

   :returns: Dataframe, unrolled version. Identical to input if none of
             rows had any ranges.


.. py:function:: unroll_complump(complump_df: pandas.DataFrame) -> pandas.DataFrame

   Unrolls the COMPLUMP keyword where K2>K1. Uses the unrolldf function,
   but this function gives more precise handling of errors.

   Example::

     COMPLUMP
      'OP1' 74 135 7 8 1 /
     /

   is transformed/unrolled to the dataframe representation of::

     COMPLUMP
      'OP1' 74 135 7 7 1 /
      'OP1' 74 135 8 8 1 /
     /

   :param dframe: Dataframe to be unrolled

   :returns: Dataframe, unrolled version.


.. py:function:: expand_wlist(wlist_df: pandas.DataFrame) -> pandas.DataFrame

   Expand all WLIST actions in a dataframe into a dataframe with
   only "NEW" actions. This makes the dataframe cheaper to parse to
   get the state of the well lists at a particular date

   Example:

   .. code-block::

     WLIST
       '*OP' NEW OP1 /
       '*OP' ADD OP2 /
     /

   is transformed into the equivalent dataframe representation of:

   .. code-block::

     WLIST
       '*OP' NEW OP1 OP2 /  -- wells always sorted alphabetically
     /

   and then similarly for more complex MOV, DEL and NEW actions.

   The rationale is that if you extract all WLIST rows at a date
   and there are only NEW actions present, you can trust that dataframe
   to contain all WLIST actions accumulated from the start.

   Warning: If multiple WLIST keywords are at the same date, with other
   keywords depending on the WLIST state in between, that effect is lost
   through this dataframe representation.

   :param wlist_df: Dataframe with WLIST action rows. DATE
                    must be present as a column in the DataFrame
   :type wlist_df: pd.DataFrame

   :returns: pd.DataFrame. WLIST rows with only NEW directives


.. py:function:: expand_complump_in_welopen_df(welopen_df: pandas.DataFrame, complump_df: pandas.DataFrame) -> pandas.DataFrame

   Go through all elements of WELOPEN and expand the rows
   referring to COMPLUMPS. The output dataframe is as if the
   connections were refered to explicitly in WELOPEN:

   Example: COMPLUMP and WELOPEN keywords::

     COMPLUMP
      'OP1' 74 135 7 7 1 /
      'OP1' 74 136 8 8 1 /
      'OP1' 74 136 9 9 2 /
      'OP1' 74 137 10 10 3 /
     /
     WELOPEN
      'OP1' 'SHUT' 3* 1 1 /
     /

   is transformed into the equivalent dataframe representation of::

     WELOPEN
      'OP1' 'SHUT' 74 135 7 /
      'OP1' 'SHUT' 74 135 8 /
     /

   :param welopen_df: Dataframe with WELOPEN actions
   :param complump_df: Dataframe with COMPLUMP records. Optional.

   :returns: welopen_df with complump expanded to actual connections.


.. py:function:: expand_wlist_in_welopen_df(welopen_df: pandas.DataFrame, wlist_df: pandas.DataFrame) -> pandas.DataFrame

   Go trough a welopen dataframe and expand rows where the well-name refers
   to a well-list. The returned dataframe is as if the welopen commands were
   inputted explicitly without the use of WLIST.


.. py:function:: applywelopen(compdat_df: pandas.DataFrame, welopen_df: pandas.DataFrame, wlist_df: pandas.DataFrame | None = None, complump_df: pandas.DataFrame | None = None) -> pandas.DataFrame

   Apply WELOPEN actions to the COMPDAT dataframe.

   Each record in the WELOPEN keyword acts as an operator on existing connections
   in existing wells.

   Example: COMPDAT and WELOPEN keyword::

     COMPDAT
      'OP1' 33 44 10 11 'OPEN' /
      'OP2' 66 44 10 11 'OPEN' /
     /
     WELOPEN
      'OP1' SHUT /
      'OP2' SHUT 66 44 10 /
     /

   This :term:`deck` would define two wells where OP1 and OP2 have two
   connected grid cells each. The first welopen statment acts on the whole
   well, closing both the well and the connections. If this statement used STOP
   instead of SHUT, the connections would be left open. The second welopen
   statement acts on a single connection. Here SHUT and STOP would give the
   same result. This behavior has been proven to be correct in the simulator.
   The Eclipse manual states that 'If items 3 - 7 are all defaulted, the
   Open/Shut/Stop command applies to the well, leaving the connections
   unchanged', but this has been proven to be wrong. The state of the
   connection can be tested by looking at the CPI summary vectors. The
   connection is SHUT if CPI==0 and OPEN if CPI>0.

   WELOPEN can also be used at different dates and changes therefore the state of
   connections without explicit use of the COMPDAT keyword. This function translates
   WELOPEN actions into explicit additional COMPDAT definitions in the exported df.

   :param compdat_df: Dataframe with unrolled COMPDAT data
   :param welopen_df: Dataframe with WELOPEN actions
   :param wlist_df: Dataframe with WLIST NEW records. Optional.
   :param complump_df: Dataframe with COMPLUMP records. Optional.

   :returns: compdat_df now including WELOPEN actions


.. py:function:: fill_parser(parser: argparse.ArgumentParser) -> argparse.ArgumentParser

   Set up sys.argv parsers.

   :param parser: parser to fill with arguments


.. py:function:: compdat_main(args: argparse.Namespace) -> None

   Entry-point for module, for command line utility


.. py:function:: df(resdatafiles: res2df.resdatafiles.ResdataFiles, initvectors: list[str] | None = None, zonemap: dict[int, str] | None = None) -> pandas.DataFrame

   Main function for Python API users

   Supports only COMPDAT information for now. Will
   add a zone-name if a zonefile is found alongside.
   If a zonemap is passed it will override the zonefile.

   :returns: pd.Dataframe with one row pr cell to well connection


