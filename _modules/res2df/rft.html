<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>res2df.rft &mdash; res2df 1.0.1.dev3+gbf4029aa documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            res2df
              <img src="../../_static/equinor-logo2.jpg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0.1.dev3+gbf4029aa
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage and examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../res2csv.html">res2csv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../csv2res.html">csv2res</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribution.html">Contributing to res2df</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../res2df/res2df.html"><code class="docutils literal notranslate"><span class="pre">res2df</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">res2df</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">res2df.rft</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for res2df.rft</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Converter module for simulator RFT output files to Pandas Dataframes</span>

<span class="sd">If MULTISEG wells are found, the segment data associated to</span>
<span class="sd">a connection is merged onto the same row as additional columns,</span>
<span class="sd">assuming connections do not point to more than one segment.</span>

<span class="sd">If ICD segments are detected (recognized as branches only containing</span>
<span class="sd">one segment), they are merged into the same row that already contains</span>
<span class="sd">connection data (CONxxxxx) and its segment data (now giving</span>
<span class="sd">information for the conditions in the tubing).</span>

<span class="sd">The columns representing SEGxxxxx data on ICD segments are renamed</span>
<span class="sd">by adding the prefix ``ICD_``</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">resdata.resfile</span> <span class="kn">import</span> <span class="n">ResdataFile</span>

<span class="kn">from</span> <span class="nn">.common</span> <span class="kn">import</span> <span class="n">merge_zones</span><span class="p">,</span> <span class="n">write_dframe_stdout_file</span>
<span class="kn">from</span> <span class="nn">.gruptree</span> <span class="kn">import</span> <span class="n">tree_from_dict</span>
<span class="kn">from</span> <span class="nn">.res2csvlogger</span> <span class="kn">import</span> <span class="n">getLogger_res2csv</span>
<span class="kn">from</span> <span class="nn">.resdatafiles</span> <span class="kn">import</span> <span class="n">ResdataFiles</span>

<span class="n">logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># In debug mode, these columns will be exported to three csv files.</span>
<span class="n">CON_TOPOLOGY_COLS</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;CONIDX&quot;</span><span class="p">,</span> <span class="s2">&quot;CONBRNO&quot;</span><span class="p">,</span> <span class="s2">&quot;CONSEGNO&quot;</span><span class="p">,</span> <span class="s2">&quot;CONNXT&quot;</span><span class="p">,</span> <span class="s2">&quot;DEPTH&quot;</span><span class="p">}</span>
<span class="n">SEG_TOPOLOGY_COLS</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;SEGIDX&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEGBRNO&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEGBRNO_upstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEGNXT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEGNXT_upstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;JUNCTION&quot;</span><span class="p">,</span>
    <span class="s2">&quot;JUNCTION_downstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LONELYSEG&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LEAF&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEGDEPTH&quot;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">ICD_TOPOLOGY_COLS</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;ICD_SEGBRNO_upstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_SEGIDX_upstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_LEAF&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_JUNCTION&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_LONELYSEG&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_JUNCTION_downstream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_SEGBRNO&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_SEGNXT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_SEGIDX&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ICD_SEGDEPTH&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_rftrecords2df</span><span class="p">(</span><span class="n">rftfile</span><span class="p">:</span> <span class="n">ResdataFile</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a dataframe just for navigation on the RFT records,</span>
<span class="sd">    from the attribute &#39;headers&#39; in ResdataFile object constructed from the</span>
<span class="sd">    binary RFT file</span>

<span class="sd">    The dataframe will consist of the columns and with example data:</span>
<span class="sd">        timeindex, recordidx, recordname, recordlength, recordtype</span>
<span class="sd">        0, 0, TIME, 1, REAL</span>
<span class="sd">        0, 1, DATE, 3, INTE</span>
<span class="sd">        0, 2, WELLETC, 16,  CHAR</span>
<span class="sd">        ...</span>
<span class="sd">        1, 30, TIME, 1, REAL</span>
<span class="sd">        1, 31, DATE, 3, INTE</span>
<span class="sd">        ....</span>
<span class="sd">        3, 89, SWAT, 14, REAL</span>

<span class="sd">    where the column recordidx refers to the RFT file such that</span>
<span class="sd">        rftfile[89] = EclKW(size=14, name=&quot;SWAT&quot;, ...)</span>

<span class="sd">    Args:</span>
<span class="sd">        rftfile (ResdataFile)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nav_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rftfile</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>
    <span class="n">nav_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">,</span> <span class="s2">&quot;recordlength&quot;</span><span class="p">,</span> <span class="s2">&quot;recordtype&quot;</span><span class="p">]</span>
    <span class="n">nav_df</span><span class="p">[</span><span class="s2">&quot;timeindex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># the TIME record (in recordname) signifies that the forthcoming records</span>
    <span class="c1"># belong to  this TIME value, and we make a new column in the header data that</span>
    <span class="c1"># tells us the row number for the associated TIME record</span>
    <span class="n">nav_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nav_df</span><span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;TIME&quot;</span><span class="p">,</span> <span class="s2">&quot;timeindex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nav_df</span><span class="p">[</span>
        <span class="n">nav_df</span><span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;TIME&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">index</span>
    <span class="n">nav_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>  <span class="c1"># forward fill (because any record is associated to the previous TIME record)</span>
    <span class="n">nav_df</span><span class="p">[</span><span class="s2">&quot;timeindex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nav_df</span><span class="p">[</span><span class="s2">&quot;timeindex&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Located </span><span class="si">%s</span><span class="s2"> RFT headers at </span><span class="si">%s</span><span class="s2"> distinct dates&quot;</span><span class="p">,</span>
        <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nav_df</span><span class="p">)),</span>
        <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nav_df</span><span class="p">[</span><span class="s2">&quot;timeindex&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())),</span>
    <span class="p">)</span>
    <span class="n">nav_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;recordidx&quot;</span>
    <span class="k">return</span> <span class="n">nav_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>


<div class="viewcode-block" id="rftrecords"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.rftrecords">[docs]</a><span class="k">def</span> <span class="nf">rftrecords</span><span class="p">(</span><span class="n">rftfile</span><span class="p">:</span> <span class="n">ResdataFile</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generator for looping over RFT records in a ResdataFile object.</span>

<span class="sd">    Each returned RFT record is represented as a dict with the keys:</span>
<span class="sd">        headers: pd.DataFrame, indexed by recordname</span>

<span class="sd">    Args:</span>
<span class="sd">        ResdataFile made from a binary RFT file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">navigation_frame</span> <span class="o">=</span> <span class="n">_rftrecords2df</span><span class="p">(</span><span class="n">rftfile</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">timeindex</span><span class="p">,</span> <span class="n">headers</span> <span class="ow">in</span> <span class="n">navigation_frame</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;timeindex&quot;</span><span class="p">):</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;recordname&quot;</span><span class="p">)</span>
        <span class="n">rftrecord</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;headers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">headers</span>
        <span class="c1"># All rows in nav_record_df represents  the data in the current</span>
        <span class="c1"># RFT record</span>
        <span class="n">dateidx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">headers</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">][</span><span class="s2">&quot;recordidx&quot;</span><span class="p">])</span>
        <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span>
            <span class="n">rftfile</span><span class="p">[</span><span class="n">dateidx</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">rftfile</span><span class="p">[</span><span class="n">dateidx</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">rftfile</span><span class="p">[</span><span class="n">dateidx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rftfile</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">headers</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;WELLETC&quot;</span><span class="p">][</span><span class="s2">&quot;recordidx&quot;</span><span class="p">])][</span>
            <span class="mi">1</span>
        <span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellmodel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rftfile</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">headers</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;WELLETC&quot;</span><span class="p">][</span><span class="s2">&quot;recordidx&quot;</span><span class="p">])][</span>
            <span class="mi">6</span>
        <span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1"># wellmodel is either &quot;STANDARD&quot; or &quot;MULTISEG&quot;</span>

        <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;timeindex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timeindex</span>
        <span class="k">yield</span> <span class="n">rftrecord</span></div>


<div class="viewcode-block" id="get_con_seg_data"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.get_con_seg_data">[docs]</a><span class="k">def</span> <span class="nf">get_con_seg_data</span><span class="p">(</span>
    <span class="n">rftrecord</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">rftfile</span><span class="p">:</span> <span class="n">ResdataFile</span><span class="p">,</span> <span class="n">datatype</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a dataframe of CON* or SEG* data for a specific RFT record,</span>
<span class="sd">    that is for one well at one date.</span>

<span class="sd">    Dataframe will for datatype==&quot;CON&quot; look like::</span>

<span class="sd">      DEPTH, SWAT, CONKH, CONIDX, ..</span>
<span class="sd">      2300,  0.3, 3000, 1</span>
<span class="sd">      2310, 0.2, 1231, 2</span>

<span class="sd">    and number of rows will equal the number of connected cells (COMPDAT lines)</span>

<span class="sd">    If it is for SEG data, all columns are prefixed by SEG</span>
<span class="sd">    and row count will be the number of segments defined in WELSEGS</span>

<span class="sd">    Args:</span>
<span class="sd">        rftrecord: Data for one RFT record, provided by rftrecords()</span>
<span class="sd">        rftfile:</span>
<span class="sd">        datatype: Either &quot;CON&quot; or &quot;SEG&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">datatype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CON&quot;</span><span class="p">,</span> <span class="s2">&quot;SEG&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;datatype must equal CON or SEG&quot;</span><span class="p">)</span>

    <span class="n">headers</span> <span class="o">=</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;headers&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;CON&quot;</span><span class="p">:</span>
        <span class="n">rft_row_count</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;DEPTH&quot;</span><span class="p">][</span><span class="s2">&quot;recordlength&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rft_row_count</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;SEGDEPTH&quot;</span><span class="p">][</span><span class="s2">&quot;recordlength&quot;</span><span class="p">]</span>

    <span class="n">data_headers</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="n">headers</span><span class="o">.</span><span class="n">recordlength</span> <span class="o">==</span> <span class="n">rft_row_count</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span>
        <span class="p">[</span><span class="s2">&quot;recordidx&quot;</span><span class="p">,</span> <span class="s2">&quot;recordname&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="c1"># If CON type, ensure, no SEG data included, and vice versa</span>
    <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;CON&quot;</span><span class="p">:</span>
        <span class="n">data_headers</span> <span class="o">=</span> <span class="n">data_headers</span><span class="p">[</span><span class="o">~</span><span class="n">data_headers</span><span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;SEG&quot;</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_headers</span> <span class="o">=</span> <span class="n">data_headers</span><span class="p">[</span><span class="n">data_headers</span><span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;SEG&quot;</span><span class="p">)]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="n">row</span><span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">]:</span> <span class="nb">list</span><span class="p">(</span><span class="n">rftfile</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;recordidx&quot;</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data_headers</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># Ensure integer headers are integers:</span>
    <span class="n">integer_columns</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="n">headers</span><span class="p">[</span><span class="s2">&quot;recordtype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;INTE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">integer_columns</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;DATE&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">data_headers</span><span class="p">[</span><span class="s2">&quot;recordname&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="n">datatype</span> <span class="o">+</span> <span class="s2">&quot;IDX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Add an index that starts with 1</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="count_wellbranches"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.count_wellbranches">[docs]</a><span class="k">def</span> <span class="nf">count_wellbranches</span><span class="p">(</span><span class="n">seg_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From a segment dataframe, coming from get_con_seg_data(..., &quot;SEG&quot;)</span>
<span class="sd">    determine the number of well branche.</span>

<span class="sd">    ICD segments must be split out first using split_seg_icd(), otherwise</span>
<span class="sd">    results are not reliable.</span>

<span class="sd">    Args:</span>
<span class="sd">        pd.DataFrame, with at least the columns SEGIDX, SEGNXT and SEGBRNO</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;LEAF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seg_data</span><span class="p">:</span>
        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">process_seg_topology</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>

    <span class="n">branchcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">seg_data</span><span class="p">[</span><span class="o">~</span><span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;LEAF&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;JUNCTION_downstream&quot;</span><span class="p">]][</span><span class="s2">&quot;SEGBRNO&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># logger.debug(&quot;Branches found: %d&quot;, count_wellbranches(merged))</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">branchcount</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_seg_topology"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.process_seg_topology">[docs]</a><span class="k">def</span> <span class="nf">process_seg_topology</span><span class="p">(</span><span class="n">seg_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine and process the segment topology.</span>

<span class="sd">    The topology of the well segments are determined by the SEGNXT column in</span>
<span class="sd">    incoming dataframe, which corresponds to SEGIDX.</span>

<span class="sd">    SEGNXT points to the next segment downstream in a production well (and</span>
<span class="sd">    injector wells are treated as production here). Downstream is thus *upwards*</span>
<span class="sd">    in space, towards the sea.</span>

<span class="sd">    The last segment in a non-icd well gets the type TUBING.</span>

<span class="sd">    Args:</span>
<span class="sd">        seg_data: Segment structure defined as a table with at least</span>
<span class="sd">            the columns SEGIDX, SEGNXT</span>

<span class="sd">    Returns:</span>
<span class="sd">        Augmented dataframe, extra columns and perhaps extra rows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">{</span><span class="s2">&quot;SEGIDX&quot;</span><span class="p">,</span> <span class="s2">&quot;SEGNXT&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient topology columns in dataframe&quot;</span><span class="p">)</span>

    <span class="n">seg_data</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;SEGIDX&quot;</span><span class="p">)</span>
    <span class="c1"># For the first segment, None is allowed as SEGNXT, which excludes</span>
    <span class="c1"># int as a  Pandas type. Convert to 0 for the moment</span>
    <span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;SEGNXT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;SEGNXT&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Outer merge first to add the upstream segment information to every row.</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">seg_data</span><span class="p">,</span>
        <span class="n">seg_data</span><span class="p">,</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;SEGIDX&quot;</span><span class="p">,</span>
        <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;SEGNXT&quot;</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_upstream&quot;</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGNXT_upstream&quot;</span><span class="p">]</span>
    <span class="c1"># Later this might be changed to use the Pandas nullable integer type, but</span>
    <span class="c1"># using zero for NaN works in this context.</span>
    <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGBRNO_upstream&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGBRNO_upstream&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Now we can determine leaf segments by those with no extra information, since</span>
    <span class="c1"># we did an outer merge:</span>
    <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;LEAF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>

    <span class="c1"># Flag segments that have multiple upstream segments as junctions</span>
    <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;JUNCTION&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGIDX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Determine if a segment is alone on its own branch</span>
    <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;LONELYSEG&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;SEGBRNO&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># We also want to flag the segment that is upstream a junction,</span>
    <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;JUNCTION_downstream&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">merged</span><span class="p">[</span><span class="n">merged</span><span class="p">[</span><span class="s2">&quot;JUNCTION&quot;</span><span class="p">]][</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">],</span> <span class="s2">&quot;JUNCTION_downstream&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">merged</span></div>


<div class="viewcode-block" id="seg2dicttree"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.seg2dicttree">[docs]</a><span class="k">def</span> <span class="nf">seg2dicttree</span><span class="p">(</span><span class="n">seg_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a nested dictionary representing the</span>
<span class="sd">    well through its segment topology</span>

<span class="sd">    Args:</span>
<span class="sd">        seg_data: topology determined by SEGIDX</span>
<span class="sd">            and SEGIDX_upstream</span>

<span class="sd">    Returns:</span>
<span class="sd">        Nested dict,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="s2">&quot;LEAF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seg_data</span><span class="p">:</span>
        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">process_seg_topology</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>
    <span class="n">subtrees</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of tuples</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;SEGIDX_upstream&quot;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;SEGIDX&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;SEGIDX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">{}}</span>
    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">subtrees</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtrees</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>

    <span class="n">children</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">root</span><span class="p">:</span> <span class="n">subtrees</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="pretty_print_well"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.pretty_print_well">[docs]</a><span class="k">def</span> <span class="nf">pretty_print_well</span><span class="p">(</span><span class="n">seg_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a multiline string with the segment structure</span>
<span class="sd">    pretty printed as an ASCII tree.</span>

<span class="sd">    Args:</span>
<span class="sd">        seg_data: Segment dataframe</span>

<span class="sd">    Returns:</span>
<span class="sd">        Multiline string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dicttree</span> <span class="o">=</span> <span class="n">seg2dicttree</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree_from_dict</span><span class="p">(</span><span class="n">dicttree</span><span class="p">))</span></div>


<div class="viewcode-block" id="split_seg_icd"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.split_seg_icd">[docs]</a><span class="k">def</span> <span class="nf">split_seg_icd</span><span class="p">(</span><span class="n">seg_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split a segment dataframe into a dataframe</span>
<span class="sd">    with non-ICD segments and one with.</span>

<span class="sd">    The segment properties (data) are merged into the downstream segments</span>
<span class="sd">    dataset, with the SEG prefixed switched to ICD.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dataframe with the ICD segments only. Empty if no ICDs found.</span>
<span class="sd">        and wider.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure we have some topology data present:</span>
    <span class="k">if</span> <span class="s2">&quot;LEAF&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seg_data</span><span class="p">:</span>
        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">process_seg_topology</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>

    <span class="n">icd_present</span> <span class="o">=</span> <span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;SEGBRNO&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">count_wellbranches</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">icd_present</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">seg_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">())</span>

    <span class="c1"># ICD segments are those where:</span>
    <span class="c1">#  * Leaf segments (connected reservoir / con_data row)</span>
    <span class="c1">#  # * Downstream segment is not a junction (because it must</span>
    <span class="c1">#    be connected to a tubing segment, which is again connected</span>
    <span class="c1">#    to a junction) (this might be too strict?)</span>
    <span class="c1">#    STOP: Cannot use this criteria, because junctions  due to ICDs</span>
    <span class="c1">#    are legit.</span>
    <span class="c1">#  * The segment must be on a branch with only one segment</span>
    <span class="n">icd_seg_indices</span> <span class="o">=</span> <span class="n">seg_data</span><span class="p">[</span><span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;LEAF&quot;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;LONELYSEG&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
    <span class="n">non_icd_seg_indices</span> <span class="o">=</span> <span class="n">seg_data</span><span class="p">[</span>
        <span class="o">~</span><span class="p">(</span><span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;LEAF&quot;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">seg_data</span><span class="p">[</span><span class="s2">&quot;LONELYSEG&quot;</span><span class="p">])</span>
    <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

    <span class="n">icd_seg_data</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">icd_seg_indices</span><span class="p">)</span>
    <span class="n">seg_data</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">non_icd_seg_indices</span><span class="p">)</span>

    <span class="n">icd_seg_data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ICD_&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">icd_seg_data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s2">&quot;Found </span><span class="si">%d</span><span class="s2"> ICD segments, indices </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">icd_seg_data</span><span class="p">),</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">icd_seg_data</span><span class="p">[</span><span class="s2">&quot;ICD_SEGIDX&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">seg_data</span><span class="p">,</span> <span class="n">icd_seg_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="merge_icd_seg_conseg"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.merge_icd_seg_conseg">[docs]</a><span class="k">def</span> <span class="nf">merge_icd_seg_conseg</span><span class="p">(</span>
    <span class="n">con_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">seg_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">icd_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge ICD segments to the CONxxxxx data. We will be</span>
<span class="sd">    connection-centric in the outputted rows, that is</span>
<span class="sd">    one row pr. connection. If the setup is with more</span>
<span class="sd">    than one segment pr. connection (e.g. reservoir</span>
<span class="sd">    cell), then we would have to be smarter. Either</span>
<span class="sd">    averaging the properties, or be segment-centric in</span>
<span class="sd">    the output.</span>

<span class="sd">    Petrel happily puts many ICD segments to the same</span>
<span class="sd">    connection. This setup is a bug, with partially</span>
<span class="sd">    unknown effects when simulated in Eclipse. Should we</span>
<span class="sd">    warn the user??</span>

<span class="sd">    Args:</span>
<span class="sd">        con_data: Connection data (CONxxxx columns). One</span>
<span class="sd">            row pr. reservoir connection</span>
<span class="sd">        seg_data: Segment data, SEGxxxxx cols, one row pr. segment, and</span>
<span class="sd">            each segment should correspond to one ICD or to one reservoir connection.</span>
<span class="sd">            Supply empty or None if no segments found.</span>
<span class="sd">        icd_data: ICD data, ICD_SEGxxxx columns. One row pr</span>
<span class="sd">            ICD segment. One-to-one correspondence to con_data through ICD_SEGBRNO</span>
<span class="sd">            and CONBRNO required. Can be empty or None if no ICD present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seg_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">icd_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">icd_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing connection data to con.csv&quot;</span><span class="p">)</span>
        <span class="n">con_data</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">CON_TOPOLOGY_COLS</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">con_data</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="s2">&quot;con.csv&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing segment data to seg.csv&quot;</span><span class="p">)</span>
        <span class="n">seg_data</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">SEG_TOPOLOGY_COLS</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="s2">&quot;seg.csv&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Writing ICD data to icd.csv&quot;</span><span class="p">)</span>
        <span class="n">icd_data</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ICD_TOPOLOGY_COLS</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">icd_data</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="s2">&quot;icd.csv&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">icd_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="c1"># Merge ICD_* columns onto the dataframe representing reservoir</span>
        <span class="c1"># connections.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">con_data</span><span class="p">,</span> <span class="n">icd_data</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;CONSEGNO&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;ICD_SEGIDX&quot;</span><span class="p">)</span>

        <span class="c1"># Merge SEGxxxxx to the dataframe with icd&#39;s and reservoir connections.</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">empty</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">seg_data</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;ICD_SEGNXT&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;SEGIDX&quot;</span>
        <span class="p">)</span>

        <span class="c1"># The merge has potentially included extra rows due to junctions.</span>
        <span class="c1"># After ICD merge, we can require that SEGIDX_upstream equals CONSEGNO</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;CONSEGNO&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;SEGIDX_upstream&quot;</span><span class="p">]]</span>

        <span class="c1"># Now the data for a reservoir connection, its ICD segment and the tubing</span>
        <span class="c1">#  segment is on the same row in the dataframe.</span>

        <span class="c1"># Gather connections that are not associated to ICDs:</span>
        <span class="n">no_icd_con_segments</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">con_data</span><span class="p">[</span><span class="s2">&quot;CONSEGNO&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">icd_data</span><span class="p">[</span><span class="s2">&quot;ICD_SEGIDX&quot;</span><span class="p">])</span>
        <span class="n">con_data_no_icd</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">con_data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;CONSEGNO&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">no_icd_con_segments</span><span class="p">)]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">con_data_no_icd</span> <span class="o">=</span> <span class="n">con_data</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">con_data_no_icd</span><span class="p">,</span> <span class="n">seg_data</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;CONSEGNO&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;SEGIDX&quot;</span>
                <span class="p">),</span>
            <span class="p">],</span>
            <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Non-multisegment wells have only reservoir connection data.</span>
        <span class="k">return</span> <span class="n">con_data</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="add_extras"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.add_extras">[docs]</a><span class="k">def</span> <span class="nf">add_extras</span><span class="p">(</span><span class="n">dframe</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add extra nice-to-have columns to the dataframe</span>
<span class="sd">    with tubing, icd-segments, and reservoir  connections matched</span>
<span class="sd">    on rows</span>

<span class="sd">    Args:</span>
<span class="sd">        dframe: Dataframe typically obtained from merge_icd_seg()</span>
<span class="sd">        inplace: Set to False if the original should not be modified.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The (possibly) augmented incoming dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">dframe</span> <span class="o">=</span> <span class="n">dframe</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="s2">&quot;CONPRES&quot;</span> <span class="ow">in</span> <span class="n">dframe</span> <span class="ow">and</span> <span class="s2">&quot;SEGPRES&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;COMPLETION_DP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nonzero_pres</span> <span class="o">=</span> <span class="p">(</span><span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONPRES&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;SEGPRES&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nonzero_pres</span><span class="p">,</span> <span class="s2">&quot;COMPLETION_DP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nonzero_pres</span><span class="p">,</span> <span class="s2">&quot;CONPRES&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nonzero_pres</span><span class="p">,</span> <span class="s2">&quot;SEGPRES&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dframe</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;DRAWDOWN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set a default so that the column always exists</span>

    <span class="k">if</span> <span class="s2">&quot;CONPRES&quot;</span> <span class="ow">in</span> <span class="n">dframe</span> <span class="ow">and</span> <span class="s2">&quot;PRESSURE&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">nonzero_conpres</span> <span class="o">=</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONPRES&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">dframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nonzero_conpres</span><span class="p">,</span> <span class="s2">&quot;DRAWDOWN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nonzero_conpres</span><span class="p">,</span> <span class="s2">&quot;PRESSURE&quot;</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">dframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nonzero_conpres</span><span class="p">,</span> <span class="s2">&quot;CONPRES&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;PRESSURE&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONBPRES&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;PRESSURE&quot;</span><span class="p">]</span>  <span class="c1"># Just an alias</span>
    <span class="k">if</span> <span class="s2">&quot;CONLENEN&quot;</span> <span class="ow">in</span> <span class="n">dframe</span> <span class="ow">and</span> <span class="s2">&quot;CONLENST&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONMD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENST&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENEN&quot;</span><span class="p">])</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENTH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENEN&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENST&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="s2">&quot;CONORAT&quot;</span> <span class="ow">in</span> <span class="n">dframe</span> <span class="ow">and</span> <span class="s2">&quot;CONLENTH&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONORATS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONORAT&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENTH&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;CONWRAT&quot;</span> <span class="ow">in</span> <span class="n">dframe</span> <span class="ow">and</span> <span class="s2">&quot;CONLENTH&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONWRATS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONWRAT&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENTH&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;CONGRAT&quot;</span> <span class="ow">in</span> <span class="n">dframe</span> <span class="ow">and</span> <span class="s2">&quot;CONLENTH&quot;</span> <span class="ow">in</span> <span class="n">dframe</span><span class="p">:</span>
        <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONGRATS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONGRAT&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dframe</span><span class="p">[</span><span class="s2">&quot;CONLENTH&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">dframe</span></div>


<div class="viewcode-block" id="df"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.df">[docs]</a><span class="k">def</span> <span class="nf">df</span><span class="p">(</span>
    <span class="n">resdatafiles</span><span class="p">:</span> <span class="n">ResdataFiles</span><span class="p">,</span>
    <span class="n">wellname</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Loop over an RFT file and construct a dataframe representation</span>
<span class="sd">    of the data, ordered by well and date.</span>

<span class="sd">    Args:</span>
<span class="sd">        resdatafiles: Object used to locate the RFT file</span>
<span class="sd">        wellname: If provided, only wells matching this string exactly</span>
<span class="sd">            will be included</span>
<span class="sd">        date: If provided, all other dates will be ignored. YYYY-MM-DD.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rftfile</span> <span class="o">=</span> <span class="n">resdatafiles</span><span class="o">.</span><span class="n">get_rftfile</span><span class="p">()</span>

    <span class="n">rftdata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">rftrecord</span> <span class="ow">in</span> <span class="n">rftrecords</span><span class="p">(</span><span class="n">rftfile</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wellname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellname&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">wellname</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">date</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Extracting </span><span class="si">%s</span><span class="s2"> well </span><span class="si">%s</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">, record index: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellmodel&quot;</span><span class="p">],</span>
            <span class="nb">str</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellname&quot;</span><span class="p">],</span> <span class="mi">8</span><span class="p">),</span>
            <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">],</span>
            <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;timeindex&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">headers</span> <span class="o">=</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;headers&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;DEPTH&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Well </span><span class="si">%s</span><span class="s2"> has no data to extract at </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellname&quot;</span><span class="p">]),</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">con_data</span> <span class="o">=</span> <span class="n">get_con_seg_data</span><span class="p">(</span><span class="n">rftrecord</span><span class="p">,</span> <span class="n">rftfile</span><span class="p">,</span> <span class="s2">&quot;CON&quot;</span><span class="p">)</span>

        <span class="c1"># Process multisegment data (not necessarily the same number</span>
        <span class="c1"># of rows as the connection data). Data for segments</span>
        <span class="c1"># that are not associated with a connection will not be</span>
        <span class="c1"># included.</span>

        <span class="n">has_seg_data</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;SEG&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellmodel&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;MULTISEG&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_seg_data</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Well </span><span class="si">%s</span><span class="s2"> is a multisegment well, but has no SEG data&quot;</span><span class="p">,</span>
                <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellname&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="c1"># This should probably never happen (?)</span>

        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">icd_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">has_seg_data</span><span class="p">:</span>
            <span class="n">seg_data</span> <span class="o">=</span> <span class="n">get_con_seg_data</span><span class="p">(</span><span class="n">rftrecord</span><span class="p">,</span> <span class="n">rftfile</span><span class="p">,</span> <span class="s2">&quot;SEG&quot;</span><span class="p">)</span>

            <span class="c1"># For each downstream segment, merge in the data for its</span>
            <span class="c1"># upstream segment, and determine leaf nodes:</span>
            <span class="n">seg_data</span> <span class="o">=</span> <span class="n">process_seg_topology</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">pretty_print_well</span><span class="p">(</span><span class="n">seg_data</span><span class="p">))</span>

            <span class="c1"># NB: The enumeration of branches is not necessarily consecutive</span>
            <span class="c1"># from SEGBRNO.</span>

            <span class="c1"># Now we can test if we have any ICD segments, that is the</span>
            <span class="c1"># case if we have any segments that have SEGBRNO higher than</span>
            <span class="c1"># the branch count.</span>

            <span class="n">seg_data</span><span class="p">,</span> <span class="n">icd_data</span> <span class="o">=</span> <span class="n">split_seg_icd</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>

            <span class="c1"># Branch counting must be done after ICD&#39;s are split out.</span>
            <span class="n">branchcount</span> <span class="o">=</span> <span class="n">count_wellbranches</span><span class="p">(</span><span class="n">seg_data</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">%d</span><span class="s2"> branch(es), and </span><span class="si">%d</span><span class="s2"> icd segment(s)&quot;</span><span class="p">,</span> <span class="n">branchcount</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">icd_data</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">con_icd_seg</span> <span class="o">=</span> <span class="n">merge_icd_seg_conseg</span><span class="p">(</span><span class="n">con_data</span><span class="p">,</span> <span class="n">seg_data</span><span class="p">,</span> <span class="n">icd_data</span><span class="p">)</span>

        <span class="n">con_icd_seg</span> <span class="o">=</span> <span class="n">add_extras</span><span class="p">(</span><span class="n">con_icd_seg</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">con_icd_seg</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span>
        <span class="n">con_icd_seg</span><span class="p">[</span><span class="s2">&quot;WELL&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellname&quot;</span><span class="p">]</span>
        <span class="n">con_icd_seg</span><span class="p">[</span><span class="s2">&quot;WELLMODEL&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rftrecord</span><span class="p">[</span><span class="s2">&quot;wellmodel&quot;</span><span class="p">]</span>

        <span class="c1"># Delete topology columns</span>
        <span class="n">delete_cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">con_icd_seg</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;stream&quot;</span><span class="p">)}</span>
        <span class="n">delete_cols</span> <span class="o">=</span> <span class="n">delete_cols</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;LEAF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ICD_LEAF&quot;</span><span class="p">,</span>
                <span class="s2">&quot;JUNCTION&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ICD_JUNCTION&quot;</span><span class="p">,</span>
                <span class="s2">&quot;LONELYSEG&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ICD_LONELYSEG&quot;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">con_icd_seg</span> <span class="o">=</span> <span class="n">con_icd_seg</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">con_icd_seg</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="n">delete_cols</span><span class="p">)]</span>

        <span class="n">rftdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con_icd_seg</span><span class="p">)</span>

    <span class="n">rftdata_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rftdata</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Fill empty cells with zeros. This is to avoid Spotfire</span>
    <span class="c1"># interpreting columns with numbers as strings. An alternative</span>
    <span class="c1"># solution that keeps NaN would be to add a second row in the</span>
    <span class="c1"># output containing the datatype</span>
    <span class="n">rftdata_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># The HOSTGRID data seems often to be empty, check if it is and delete if so:</span>
    <span class="k">if</span> <span class="s2">&quot;HOSTGRID&quot;</span> <span class="ow">in</span> <span class="n">rftdata_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rftdata_df</span><span class="o">.</span><span class="n">HOSTGRID</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rftdata_df</span><span class="o">.</span><span class="n">HOSTGRID</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">rftdata_df</span><span class="p">[</span><span class="s2">&quot;HOSTGRID&quot;</span><span class="p">]</span>

    <span class="n">zonemap</span> <span class="o">=</span> <span class="n">resdatafiles</span><span class="o">.</span><span class="n">get_zonemap</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">zonemap</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;K&quot;</span> <span class="ow">in</span> <span class="n">rftdata_df</span><span class="p">:</span>
            <span class="n">kname</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kname</span> <span class="o">=</span> <span class="s2">&quot;CONKPOS&quot;</span>
        <span class="n">rftdata_df</span> <span class="o">=</span> <span class="n">merge_zones</span><span class="p">(</span><span class="n">rftdata_df</span><span class="p">,</span> <span class="n">zonemap</span><span class="p">,</span> <span class="n">kname</span><span class="o">=</span><span class="n">kname</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rftdata_df</span></div>


<div class="viewcode-block" id="fill_parser"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.fill_parser">[docs]</a><span class="k">def</span> <span class="nf">fill_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set up sys.argv parsers.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        parser to fill with arguments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;DATAFILE&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Name of .DATA input file for the reservoir simulator, or RFT file. &quot;</span>
            <span class="s2">&quot;If .DATA file is provided, it will look for&quot;</span>
            <span class="s2">&quot; the associated .DATA file&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--wellname&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Restrict data to one named well&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--date&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Restrict data to one date, YYYY-MM-DD&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="s2">&quot;--output&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Name of output CSV file.&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;rft.csv&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="s2">&quot;--verbose&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Be verbose&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--debug&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Debug mode&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span></div>


<div class="viewcode-block" id="rft_main"><a class="viewcode-back" href="../../res2df/res2df.rft.html#res2df.rft.rft_main">[docs]</a><span class="k">def</span> <span class="nf">rft_main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Entry-point for module, for command line utility&quot;&quot;&quot;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger_res2csv</span><span class="p">(</span>  <span class="c1"># pylint: disable=redefined-outer-name</span>
        <span class="vm">__name__</span><span class="p">,</span> <span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">DATAFILE</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.RFT&quot;</span><span class="p">):</span>
        <span class="c1"># Support the RFT file as an argument also:</span>
        <span class="n">resdatafiles</span> <span class="o">=</span> <span class="n">ResdataFiles</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">DATAFILE</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.RFT&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.DATA&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resdatafiles</span> <span class="o">=</span> <span class="n">ResdataFiles</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">DATAFILE</span><span class="p">)</span>
    <span class="n">rft_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">(</span><span class="n">resdatafiles</span><span class="p">,</span> <span class="n">wellname</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">wellname</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rft_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">wellname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">args</span><span class="o">.</span><span class="n">date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No data. Check your well and/or date filter&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No data found. Bug?&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">write_dframe_stdout_file</span><span class="p">(</span><span class="n">rft_df</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">caller_logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span></div>


<span class="c1"># Vector  Description</span>
<span class="c1"># CONIDX   Index of the connection pr well, starting at 1.</span>
<span class="c1"># CONDEPTH Depth at the centre of each connection in the well</span>
<span class="c1"># CONLENST Length down the tubing from the BH reference</span>
<span class="c1">#          point to the start of the connection</span>
<span class="c1"># CONLENEN Length down the tubing from the BH reference point to the</span>
<span class="c1">#          far end of the connection</span>
<span class="c1"># CONPRES  Pressure in the wellbore at the connection</span>
<span class="c1"># CONORAT  Oil production rate of the connection at surface conditions</span>
<span class="c1"># CONWRAT  Water production rate of the connection at surface conditions</span>
<span class="c1"># CONGRAT  Gas production rate of the connection at surface conditions</span>
<span class="c1"># CONOTUB  Oil flow rate through the tubing at the start of the</span>
<span class="c1">#          connection at surface conditions</span>
<span class="c1"># CONWTUB  Water flow rate through the tubing at the start of the</span>
<span class="c1">#          connection at surface conditions</span>
<span class="c1"># CONGTUB  Gas flow rate through the tubing at the start of the</span>
<span class="c1">#          connection at surface conditions</span>
<span class="c1"># CONVTUB  Volumetric flow rate of the mixture at the start of the connection</span>
<span class="c1"># CONFAC   Connection transmissibility factor</span>
<span class="c1"># CONKH    Connection Kh value</span>
<span class="c1"># CONNXT   Number of the neighbouring connection towards the wellhead</span>
<span class="c1"># CONSEGNO Segment number containing the connection</span>
<span class="c1"># CONBRNO  Branch number containing the connection</span>
<span class="c1"># CONIPOS  I location of the connection</span>
<span class="c1"># CONJPOS  J location of the connection</span>
<span class="c1"># CONKPOS  K location of the connection</span>
<span class="c1"># CONBDEPH Depth of the grid block of the connection</span>
<span class="c1"># CONBPRES Pressure of the grid block of the connection</span>
<span class="c1">#          (Copy of the PRESSURE data)</span>
<span class="c1"># CONBSWAT Water saturation of the grid block of the connection</span>
<span class="c1"># CONBSGAS Gas saturation of the grid block of the connection</span>
<span class="c1"># CONBSOIL Oil saturation of the grid block of the connection</span>
<span class="c1"># COMPLETION Completion index of the connection</span>
<span class="c1">#</span>
<span class="c1"># The above values are taken from the corresponding RFT data.</span>
<span class="c1">#</span>
<span class="c1"># Vector   Description</span>
<span class="c1"># CONMD    Measured depth of the connection</span>
<span class="c1"># CONLENTH Length of the connection</span>
<span class="c1"># CONORATS Scaled oil production rate at surface conditions</span>
<span class="c1"># CONWRATS Scaled water production rate at surface conditions</span>
<span class="c1"># CONGRATS Scaled gas production rate at surface conditions</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Vector   Description</span>
<span class="c1"># SEGDEPTH Depth at the far end of each segment</span>
<span class="c1"># SEGLENST Length down the tubing from the zero tubing length</span>
<span class="c1">#          reference point to the start of the segment</span>
<span class="c1"># SEGLELEN Length down the tubing from the zero tubing length</span>
<span class="c1">#          reference point to the far end of the segment</span>
<span class="c1"># SEGXCORD X-coordinate at the far end of the segment</span>
<span class="c1">#          (as entered by the 11th item of the WELSEGS record)</span>
<span class="c1"># SEGXCORD Y-coordinate at the far end of the segment</span>
<span class="c1">#          (as entered by the 12th item of the WELSEGS record)</span>
<span class="c1"># SEGPRES Pressure in the wellbore at the far end of the segment</span>
<span class="c1"># SEGORAT Oil flow rate through the segment through its near end</span>
<span class="c1"># SEGWRAT Water flow rate through the segment through its near end</span>
<span class="c1"># SEGGRAT Gas flow rate through the segment through its near end</span>
<span class="c1"># SEGOVEL Free oil phase velocity through the segment</span>
<span class="c1"># SEGWVEL Water flow velocity through the segment</span>
<span class="c1"># SEGGVEL Free gas phase flow velocity through the segment</span>
<span class="c1"># SEGOHF  Free oil phase holdup fraction in the segment</span>
<span class="c1"># SEGWHF  Water holdup fraction in the segment</span>
<span class="c1"># SEGGHF  Free gas phase holdup fraction in the segment</span>
<span class="c1"># SEGBRNO Branch number of the segment</span>
<span class="c1"># SEGNXT  Number of the neighbouring segment towards the wellhead</span>
<span class="c1">#</span>
<span class="c1"># Vector         Description</span>
<span class="c1"># SEGMD          Segment measured depth</span>
<span class="c1"># SEGLENTH       Segment length</span>
<span class="c1"># SEGORATSScaled water flow rate through the segment</span>
<span class="c1"># SEGWRATSScaled water flow rate through the segment</span>
<span class="c1"># SEGGRATSScaled gas flow rate through the segment</span>
<span class="c1"># SEGCORATSummed connection oil flow rate through segment</span>
<span class="c1"># SEGCWRATSummed connection water flow rate through segment</span>
<span class="c1"># SEGCGRATSummer connection gas flow rate through segment</span>
<span class="c1"># SEGCORTSScaled summed connection oil flow rate through segment</span>
<span class="c1"># SEGCWRTSScaled summed connection water flow rate through segment</span>
<span class="c1"># SEGCGRTSScaled summed connection gas flow rate through segment</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Equinor 2019-2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #ff1243;
    }
    /* Sidebar */
    .wy-nav-side {
      background: #474747;
    }
    .wy-side-nav-search > div.version {
      color: white;
    }
  </style>


</body>
</html>